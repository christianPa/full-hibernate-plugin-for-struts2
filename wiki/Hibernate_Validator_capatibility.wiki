#summary Hibernate Validator capability

= Introduction =

Hibernate Validator is a fantastic validation framework. 

Following the DRY (Don't Repeat Yourself) principle, Hibernate Validator let's you express your domain constraints once (and only once) and ensure their compliance at various level of your system automatically.

Annotations are a very convenient and elegant way to specify invariant constraints on the domain model implementation, the persistent classes. Hibernate Validator comes bundled with a set of common validations (@NotNull, @Email, @Max, and so on), and you can build you own validation rules very easily.

More about this framework at http://www.hibernate.org/412.html

Hibernate Validator Manual:<br/>
[http://www.hibernate.org/hib_docs/validator/reference/en/pdf/hibernate_validator.pdf PDF version]<br/>
[http://www.hibernate.org/hib_docs/validator/reference/en/html_single/ HTML version]


= Usage =

This capability can be used to Validate Entity POJOs or simple fields in Actions.


==Validating Entity POJOs==

If you have an Entity class with specific validation annotations, just use the _@Valid_ annotation over a declaration or a setter method of this in the Action!

_Example:_

*Entity class: Soccerplayer.java*
{{{
    public class Soccerplayer implements java.io.Serializable {

        private Integer idplayer;
	
	@NotNull
	@Valid
	private Soccerteam soccerteam;
	
	@NotEmpty
	@Length(min=2, max=20)
	private String name;
	
	@NotNull
	@Past
	private Date birthdate;
	
	@Min(value=1)
	@Max(value=2)
	private Float height;
	
	@Length(max=100)
	private String notes;

        // ... getters and setters ...
    }
}}}
<font color="red">*=> _Validation annotations as need..._*</font><br/>
*Important: *_You can use Hibernate Validator annotations when using XML mapping files and in JPA/EJB annotated Entity classes. In both cases this plugin works fine._



*Struts XML mapping file: struts.xml
{{{
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE struts PUBLIC
    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
    "struts-2.0.dtd">
    <struts>

      <package name="main" extends="hibernate-default">
    	<action name="listPlayer" class="SoccerplayerAction" method="list">
    	    <result>/list.jsp</result>
    	</action>
    	
    	<action name="savePlayer" class="SoccerplayerAction" method="save">
    	    <interceptor-ref name="defaultStackHibernate"/>
    	    <result name="input">/form.jsp</result>
    	    <result type="redirect-action">listPlayer</result>
    	</action>
      </package>

    </struts>
}}}
<font color="red">*=> _The package extends <u>hibernate-default</u>. This is REQUIRED!_*</font>. The default interceptor stack when you extends this package is *defaultStackHibernate*, that is the responsable by the validation.<br/>



*Action class: SoccerplayerAction.java*
{{{
    public class ManagePlayersAction extends ActionSupport{
	
	@Valid
	Soccerplayer player = new Soccerplayer();
    
        // ... getters, setters and action methods ( ie. execute() ) ...

    }
}}}
<font color="red">*=> _@Valid over the POJO to be validated..._*</font>
In this Action, the *player* object will be validated in every request that use the *defaultStackHibernate* (default interceptor stack if the package extends *hibernate-defaults*). If requests to this action that don't use this stack no hibernate validation will be done.


*JSP file: form.jsp
{{{
    <%@ taglib uri="/struts-tags" prefix="s" %>

    <%@ page language="java" contentType="text/html; charset=ISO-8859-1"
    pageEncoding="ISO-8859-1"%>
    
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <s:head/>
    <title>Soccer Players</title>
    </head>
    <body>	
	<s:url id="urlList" action="listPlayer"></s:url>
	<s:a theme="ajax" href="%{urlList}" targets="divIntern" indicator="indicator" showLoadingText="false">List All Players</s:a>

	<s:form action="savePlayer">
		<s:hidden name="player.idplayer"></s:hidden>
		<s:textfield key="player.name"></s:textfield>
		<s:textfield key="player.birthdate"></s:textfield>
		<s:textfield key="player.height"></s:textfield>
		<s:textarea key="player.notes" cols="50" rows="3"></s:textarea>
		<s:select list="teamsList" name="player.soccerteam.idteam" label="Team"
		 listKey="idteam" listValue="name"
		 headerKey="" headerValue="- What Team? -"></s:select>
		<s:submit value="Save" />
	</s:form>

    </body>
    </html>
}}}
<font color="red">*=> _Input fields here use keys for the automatic generation of label and name attributes... but not just this: Please, pay attention to this keys..._*</font>


*I18N messages file: SoccerplayerAction.properties
{{{
    player.name=Player Name
    player.birthdate=Birth
    player.height=Height (m)
    player.notes=Notes about this Player
    player.soccerteam.idteam=Team
}}}
<font color="red">*=> _Please, pay attention to this keys..._*</font>

<font color="red">*=> _Ok, did you pay attention to the keys?_*</font>

Now, look to the result...

Form before submit: <br/>
<img src="http://lh3.ggpht.com/_BudW2b3yOHU/ShP02Ub6vZI/AAAAAAAAABk/5JG8RA12hLI/formSoccerPlayersBeforeSubmit.JPG" border="1"/>

<br/>

Form AFTER submit and validation:<br/>
<img src="http://lh6.ggpht.com/_BudW2b3yOHU/ShP02TyVExI/AAAAAAAAABo/gBOwfv5N7DE/formSoccerPlayersAfterSubmit.JPG" border=1/>

Did you see that the validation message had the field label as prefix? This Plugin try to use a I18N key for this! How?
If the Entity class reference at the Action is *player*, so the Value Stack keys for this will be:
  * player.name
  * player.birthdate
  * player.height
  * player.notes
  * player.soccerteam.idteam

*_So, there is another DRY pratice here!_* 

_Do i need to use message keys to use this capability?_<br/>
*NO.* If no key acording the Value Stack item name key found, the message WILL BE created BUT *without* the field label.
The result would be this: <br/>
<img src="http://lh6.ggpht.com/_BudW2b3yOHU/ShP3SEa-I-I/AAAAAAAAABs/95ofRnvpAnY/formSoccerPlayersAfterSubmitNoLabel.JPG" border=1/>



==Validating Fields in the Action==

You can validate simple fields in the Action using Hibernate Validator Annotations!

_Example:_

*Action class: MySimpleAction.java*
{{{
    public class MySimpleAction extends ActionSupport {

        private Integer myFieldNotValidated;
	
	@NotEmpty
	@Length(min=2, max=20)
	private String myValidatedField1;
	
	@NotNull
	@Past
	private Date myValidatedField2;
	
        // ... getters and setters for this 3 fields ...
    }
}}}
In this Action, there are 3 fields, but just 2 will be validated in requests (if using the *defaultStackHibernate*).


= Details _(FAQ style)_ =

*Q1:* <font color="navy">My Entity class has 10 fields with Hibernate Validator annotations, but in a specific Action in my project i would like to submit and only 3 field of this class. What can i do?</font> <br/>
*A1:* Peace of cake! This plugin validates only fields in the request. In the case on question, if the 3 fields pass in validation, the action will run fine.


*Q2:* <font color="navy">I have an Entity class object with Hibernate Validator annotations in my Action. But this Action has 2 mapped actions. In one of this i need validation and in the other, not.What can i do?</font> <br/>
*A2:* This plugin has an interceptor stack that do not validate: *basicStackHibernate*. This one only use the Hibernate Core session and transaction injections.

*Q3:* <font color="navy">What about Struts2 validations (annotations and XML)?</font> <br/>
*A3:* This plugin has 3 interceptor stacks:
  * *basicStackHibernate*: Like Struts2 *basickStack* (NO validations here!), but with Hibernate Core session and transaction injections capability.<br/>
  * *defaultStackHibernate*: Like Struts2 *defaultStack*, but _DO NOT USE_ Struts2 validation methods (annotation and XML). Uses Hibernate Validation framework instead.<br/>
  * *defaultStackHibernateStrutsValidation*: Struts2 *defaultStack* + plugin *basicStackHibernate*.